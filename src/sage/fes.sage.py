

# This file was *autogenerated* from the file fes.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0x5555555555555555 = Integer(0x5555555555555555); _sage_const_0x3333333333333333 = Integer(0x3333333333333333); _sage_const_4 = Integer(4); _sage_const_0x0f0f0f0f0f0f0f0f = Integer(0x0f0f0f0f0f0f0f0f); _sage_const_0x0101010101010101 = Integer(0x0101010101010101); _sage_const_0xffffffffffffffff = Integer(0xffffffffffffffff); _sage_const_56 = Integer(56); _sage_const_100 = Integer(100); _sage_const_5 = Integer(5); _sage_const_10 = Integer(10); _sage_const_3 = Integer(3)
import math
# from random import randint
import numpy as np
from itertools import combinations_with_replacement as cwr
from itertools import product as prod

def run_fes(f_sys, vars):
    solutions = []
    n = len(vars)
    s = init(f_sys, vars)
    if s["y"] == _sage_const_0 :
        solutions.append(_sage_const_0 )
    while s["i"] < _sage_const_2 **n - _sage_const_1 :
        s = next(s)
        if (s["y"] == _sage_const_0 ).all():
            solutions.append(gray_code(s["i"]))
    return solutions 

def next(s):
    s["i"] += _sage_const_1 
    k1 = bit1(s["i"])
    k2 = bit2(s["i"])
    if k2 > -_sage_const_1 :
        s["d1"][k1] = (s["d1"][k1] ^ s["d2"][k1,k2])
    s["y"] = (s["y"] ^ s["d1"][k1])
    return s

def init(f, vars):
    n = len(vars)
    s = dict()
    s["i"] = _sage_const_0  
    s["y"] = f[_sage_const_0 ] # Updated
    s["d2"] = np.zeros((n, n), dtype=int) # Updated
    id = [(k, j) for (k,j) in cwr(range(n), _sage_const_2 )]
    for i, (k, j) in enumerate(id):
        if k == j: continue
        s["d2"][k,j] = f[i + len(vars) + _sage_const_1 ] # Updated: High probability of error
    s["d1"] = np.zeros(n, dtype=int) # Updated
    s["d1"][_sage_const_0 ] = f[_sage_const_1 ] # Updated
    for k in range(_sage_const_1 , n):
        s["d1"][k] = s["d2"][k-_sage_const_1 ,k] ^ f[k + _sage_const_1 ]
    return s

def bitslice(f_sys, vars, m):
    f_sys_sliced = np.zeros(math.comb(len(vars) + _sage_const_2  - _sage_const_1 , _sage_const_2 ) + len(vars) + _sage_const_1 , dtype=int)
    for j, poly in enumerate(f_sys):
        f_sys_sliced[_sage_const_0 ] += int(poly.constant_coefficient()) << j
        i = _sage_const_1 
        for v in vars:
            f_sys_sliced[i] += int(poly.coefficient({v_: _sage_const_1  if v == v_ else _sage_const_0  for v_ in vars})) << j
            i += _sage_const_1 
        for v1, v2 in cwr(range(len(vars)), _sage_const_2 ):
            if v1 == v2:
                f_sys_sliced[i] += int(poly.coefficient({vars[v1]: _sage_const_2 , **{v: _sage_const_0  for v in vars if v != vars[v1]}})) << j
            else:
                f_sys_sliced[i] += int(poly.coefficient({vars[v1]: _sage_const_1 , vars[v2]: _sage_const_1 , **{v: _sage_const_0  for v in vars if v != vars[v1] and v != vars[v2]}})) << j
            i += _sage_const_1 
    return f_sys_sliced

def partial_eval(f_sys, values, n):
    N = len(values)
    f_sys_eval = [f_sys[_sage_const_0 ], *f_sys[(N + _sage_const_1 ):(n + _sage_const_1 )]] # Append constants
    for i, v0 in enumerate(values):
        f_sys_eval[_sage_const_0 ] = f_sys_eval[_sage_const_0 ] ^ (v0 * f_sys[i + _sage_const_1 ])
        for j in range(i, N):
            v1 = values[i]
            f_sys_eval[_sage_const_0 ] = f_sys_eval[_sage_const_0 ] ^ (v0 * v1 * f_sys[lex_idx(i, j, n) + n + _sage_const_1 ]) # Add evaluated linear terms
        for j in range(N, n):
            f_sys_eval[j - N + _sage_const_1 ] = f_sys_eval[j - N + _sage_const_1 ] ^ f_sys[lex_idx(i, j, n) + n + _sage_const_1 ]
    f_sys_eval = np.append(f_sys_eval, f_sys[lex_idx(N, N, n) + n + _sage_const_1 :]) # Append square terms
    return f_sys_eval

def bruteforce(system, R, n1, d):
    system = preprocess(system, R.gens())
    solutions = []
    m = len(system)
    n = len(R.gens())
    sliced = bitslice(system, R.gens(), m)
    for i in range(_sage_const_2 **(n - n1)):
        print(convert(i, n - n1), end="")
        if hamming_weight(i) > d:
            continue
        print(" x")
        pe_sliced = partial_eval(sliced, convert(i, n - n1), n - n1)
        sub_sol = run_fes(pe_sliced, R.gens()[(n - n1):])
        if sub_sol:
            solutions += [convert(i, n1) + convert(s, n - n1) for s in sub_sol]
    return solutions

def hamming_weight(x):
    x -= (x >> _sage_const_1 ) & _sage_const_0x5555555555555555 
    x = (x & _sage_const_0x3333333333333333 ) + ((x >> _sage_const_2 ) & _sage_const_0x3333333333333333 )
    x = (x + (x >> _sage_const_4 )) & _sage_const_0x0f0f0f0f0f0f0f0f 
    return ((x * _sage_const_0x0101010101010101 ) & _sage_const_0xffffffffffffffff  ) >> _sage_const_56 

def preprocess(f_sys, vars):
    for i, f in enumerate(f_sys):
        for x in f.variables():
            coeff = f.coefficient({x:_sage_const_2 })
            if coeff == _sage_const_1 :
                f_sys[i] += x
    return f_sys

def lex_idx(i, j, n):
    return sum((n - k) for k in range(i + _sage_const_1 )) - (n - j)

def bit1(i):
    return int(math.log2(i & (-i)))

def bit2(i):
    if math.log2(i).is_integer(): return -_sage_const_1 
    i &= (i - _sage_const_1 )
    i &= (-_sage_const_1 )
    return int(bit1(i))

def gray_code(i): return i ^ (i >> _sage_const_1 )

def subspace_gen(n, n1, w):
    for g in monotonic_bounded(n - n1, w + _sage_const_1 ): 
        for i in range(_sage_const_2 **n1):
            yield g + convert(i, n1)

def convert(v, n):
    v = bin(v)[_sage_const_2 :]
    return list(map(lambda i : (int(v[-i]) if i <= len(v) else _sage_const_0 ), range(_sage_const_1 , n + _sage_const_1 )))

def test_solutions(f_sys, sol, R):
    for s in range(_sage_const_2 **len(R.gens())):
        faulted_sol = False
        for f in f_sys:
            args = convert(s, len(R.gens()))
            res = f(*args) 
            faulted_sol = faulted_sol or res
            if res and (s in sol):
                print("=== Case 1 ===")
                print(R.gens())
                print(f)
                print(args)
                print(res)
                print(s)
                print("===")
                return False
        if (not faulted_sol) and (s not in sol):
            print("=== Case 2 ===")
            print(R.gens())
            print(convert(s, len(R.gens())))
            print(s)
            print([f(*convert(s, len(R.gens()))) for f in f_sys])
            print("===")
            return False
    return True

def main():
    res = True
    for i in range(_sage_const_100 ):
        f_sys = []
        m = randint(_sage_const_5 , _sage_const_10 )
        n = randint(_sage_const_2 , _sage_const_10 )
        R = GF(_sage_const_2 )[", ".join(["x" + str(i) for i in range(n)])]
        for _ in range(m):
            f = R(GF(_sage_const_2 )[R.gens()].random_element(degree=_sage_const_2 ))
            f_sys.append(f)
        f_sys_prep = preprocess(f_sys.copy(), R.gens())
        m = len(f_sys)
        f_sys_sl = bitslice(f_sys_prep, R.gens(), m)
        sol = run_fes(f_sys_sl, R.gens())
        res = test_solutions(f_sys, sol, R)
        if not res:
            print(f_sys_prep)
            print(f_sys)
            print(f_sys_sl)
            print(sol)
            print(res)
            break
    if res:
        print("No errors found for 100 trials")

if __name__ == "__main__":
    #main()
    n = _sage_const_5 
    m = _sage_const_5 
    n1 = _sage_const_3 
    R = GF(_sage_const_2 )['x0, x1, x2, x3, x4']; (x0, x1, x2, x3, x4,) = R._first_ngens(5)
    system = [x0*x2 + x0, x0*x1 + x0*x3 + x2*x4, x0*x1 + x2*x4 + x0, x1*x3 + x0*x4 + x3*x4 + x0, x1**_sage_const_2 , x0*x2 + x2*x3 + x4**_sage_const_2  + x3, x1*x2 + x3*x4 + x4**_sage_const_2  + x0 + x4]
    s = bruteforce(system, R, n1, _sage_const_2 )
    print(s)

