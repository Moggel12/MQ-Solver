

# This file was *autogenerated* from the file dinur.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_10 = Integer(10); _sage_const_6 = Integer(6); _sage_const_5 = Integer(5); _sage_const_20 = Integer(20)
from mob import mob_transform, mob_inv
from fes import bruteforce, convert
import numpy as np
from random import randint
from utils import index_of
# from monotonic_gray import monotonic_bounded

# def index_of(y_list):
#     return sum(b * 2^i for i, b in enumerate(y_list))

def random_system(m_low, m_high, n_low, n_high):
    system = []
    m = randint(m_low, m_high)
    n = randint(n_low, n_high)
    R = GF(_sage_const_2 )[", ".join(["x" + str(i) for i in range(n)])]
    rem = _sage_const_0 
    for _ in range(m):
        f = R(GF(_sage_const_2 )[R.gens()].random_element(degree=_sage_const_2 ))
        if (f != GF(_sage_const_2 )(_sage_const_0 )) and (f != GF(_sage_const_2 )(_sage_const_1 )):
            system.append(f)
        else:
            rem += _sage_const_1 
    m -= rem
    n1 = randint(_sage_const_1 , n - _sage_const_1 )
    return system, n, m, n1, R

def test_u_values(trials, verbose=False):
    for _ in range(trials):
        # system, n, m, n1, ring = random_system(5, 10, 2, 10) 
        R = GF(_sage_const_2 )['x0, x1, x2, x3, x4, x5, x6, x7, x8, x9']; (x0, x1, x2, x3, x4, x5, x6, x7, x8, x9,) = R._first_ngens(10)
        system = [x5**_sage_const_2  + x5*x6 + x4, x3**_sage_const_2  + x1*x7 + x3, x0*x2 + x2*x5 + x6, x3*x7 + x7**_sage_const_2  + x5*x9, x2*x8 + x7*x8 + x3, x6**_sage_const_2  + x4*x7 + x4*x8]
        n, m, n1, w = (_sage_const_10 , _sage_const_6 , _sage_const_2 , _sage_const_10 )
        F_tilde = product((GF(_sage_const_2 )(_sage_const_1 ) + f) for f in system)
        # w = F_tilde.degree() - n1
        if verbose:
            print(f"Checking system\n{system}\n{(n, m, n1, w)}")
        V, ZV = compute_u_values(system, R, n1, w)
        for y in range(_sage_const_2 **(n - n1)):
            s0 = sum(F_tilde(*convert(y, n - n1), *convert(z_hat, n1)) for z_hat in range(_sage_const_2 **n1))
            if V[y] != s0:
                print(f"Error found in V[{y}]\n\t{V[y]}\n\t{s0}")
                return y
            for i in range(n1):
                si = sum(F_tilde(*convert(y, n - n1), *convert(z_hat, n1 - _sage_const_1 )[:i], _sage_const_0 , *convert(z_hat, n1 - _sage_const_1 )[i:]) for z_hat in range(_sage_const_2 **(n1 - _sage_const_1 )))
                if ZV[i][y] != si:
                    print(f"Error found in ZV[{i}][{y}]\n\t{ZV[i][y]}\n\t{si}")
                    return y
        if verbose: 
            print("No errors found for system")
    print(f"No errors found in {trials} trial(s)")

def test_output_sol(trials, verbose=False):
    for _ in range(trials):
        system, n, m, n1, R = random_system(_sage_const_5 , _sage_const_10 , _sage_const_2 , _sage_const_10 )
        # R.<x0, x1, x2, x3, x4, x5, x6, x7, x8, x9> = GF(2)[]
        # system = [x5^2 + x5*x6 + x4, x3^2 + x1*x7 + x3, x0*x2 + x2*x5 + x6, x3*x7 + x7^2 + x5*x9, x2*x8 + x7*x8 + x3, x6^2 + x4*x7 + x4*x8]
        # n, m, n1, w = (10, 6, 2, 10)
        F_tilde = product((GF(_sage_const_2 )(_sage_const_1 ) + f) for f in system)
        w = F_tilde.degree() - n1
        if verbose:
            print(f"Checking system\n{system}\n{(n, m, n1, w)}")
        potentials = output_potentials(system, R, n1, w)
        for y in range(_sage_const_2 **(n - n1)):
            s0 = sum(F_tilde(*convert(y, n - n1), *convert(z_hat, n1)) for z_hat in range(_sage_const_2 **n1))
            if s0 == GF(_sage_const_2 )(_sage_const_1 ):
                if y not in potentials:
                    print(f"Error in out: {y} is not a key")
                    return y
                if potentials[y][_sage_const_0 ] != GF(_sage_const_2 )(_sage_const_1 ):
                    print(f"Error in out[{y}][0]: Not equal to 1 when sum evaluates to 1")
                    return y
                for i in range(_sage_const_1 , n1 + _sage_const_1 ):
                    si = sum(F_tilde(*convert(y, n - n1), *convert(z_hat, n1 - _sage_const_1 )[:i - _sage_const_1 ], _sage_const_0 , *convert(z_hat, n1 - _sage_const_1 )[i - _sage_const_1 :]) for z_hat in range(_sage_const_2 **(n1 - _sage_const_1 )))
                    if potentials[y][i] == si:
                        print(f"Error in out[{y}][{i}]: Value NOT inverse of the evaluation of U_{i}({y}) = {si} = {potentials[y][i]}")
                        return y
        print("No errors found for system")
    print(f"No errors found in {trials} trial(s)")

def compute_u_values(system, R, n1, w):
    n = len(R.gens())
    sols = bruteforce(system, R, n1, w + _sage_const_1 )
    l = [math.comb(n - n1, i) for i in range(w + _sage_const_2 )]
    V = {i: GF(_sage_const_2 )(_sage_const_0 ) for i in range(sum(l[:-_sage_const_1 ]))}
    ZV = {i: {j: GF(_sage_const_2 )(_sage_const_0 ) for j in range(sum(l))} for i in range(n1)}
    for s in sols:
        y, z = s[:n - n1], s[n - n1:]
        if sum(y) <= w:
            idx = index_of(y)
            V[idx] += _sage_const_1 
        for i in range(n1):
            if z[i] == _sage_const_0 :
                idx = index_of(y)
                ZV[i][idx] += _sage_const_1 
    return V, ZV

def output_potentials(system, R, n1, w):
    n = len(R.gens())
    R_sub = GF(_sage_const_2 )[", ".join([str(var) for var in R.gens()[:n - n1]])]
    V, ZV = compute_u_values(system, R, n1, w + _sage_const_1 )
    U = np.full(n1 + _sage_const_1 , GF(_sage_const_2 )(_sage_const_0 ))
    U[_sage_const_0 ] = mob_transform(V, R_sub.gens())
    for i in range(_sage_const_1 , n1 + _sage_const_1 ):
        U[i] = mob_transform(ZV[i - _sage_const_1 ], R_sub.gens())
    # print(U[1])
    # print("ZV[0][181]", ZV[0][181])
    # if U[1] not in [GF(2)(0), GF(2)(1)]: print("Truth table U_1", mob_inv(U[1]))
    # if U[1] not in [GF(2)(0), GF(2)(1)]: print("Eval", U[1](*convert(181, n - n1)))
    evals = np.full((n1 + _sage_const_1 , _sage_const_2 **(n - n1)), GF(_sage_const_2 )(_sage_const_0 ))
    for i in range(n1 + _sage_const_1 ):
        for y in range(_sage_const_2 **(n - n1)):
            # if i == 0 and y == 48: print("Eval", U[i](*convert(y, n - n1)), i, y)
            evals[i][y] = U[i](*convert(y, n - n1))
    # print("Stored", evals[1][181])
    out = np.full((_sage_const_2 **(n - n1), n1 + _sage_const_1 ), GF(_sage_const_2 )(_sage_const_0 ))
    # print("Eval U_0", U[0](*convert(181, n - n1)))
    # print("Stored U_0", evals[0][181])
    for y_hat in range(_sage_const_2 **(n - n1)):
        if evals[_sage_const_0 ][y_hat] == _sage_const_1 :
            out[y_hat][_sage_const_0 ] = GF(_sage_const_2 )(_sage_const_1 )
            for i in range(_sage_const_1 , n1 + _sage_const_1 ):
                # if i == 1 and y_hat == 181: print(evals[i][y_hat])
                out[y_hat][i] = evals[i][y_hat] + _sage_const_1 
                # if i == 1 and y_hat == 181: print(out[y_hat][i])
    return out

def solve():
    pass

def main():
    pass

if __name__ == "__main__":
    # test_u_values(1, False)
    test_output_sol(_sage_const_20 , False)

