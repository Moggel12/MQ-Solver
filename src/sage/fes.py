

# This file was *autogenerated* from the file fes.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_0x5555555555555555 = Integer(0x5555555555555555); _sage_const_0x3333333333333333 = Integer(0x3333333333333333); _sage_const_2 = Integer(2); _sage_const_4 = Integer(4); _sage_const_0x0f0f0f0f0f0f0f0f = Integer(0x0f0f0f0f0f0f0f0f); _sage_const_0x0101010101010101 = Integer(0x0101010101010101); _sage_const_0xffffffffffffffff = Integer(0xffffffffffffffff); _sage_const_56 = Integer(56); _sage_const_0 = Integer(0); _sage_const_5p4 = RealNumber('5.4'); _sage_const_10 = Integer(10)
from dataclasses import dataclass
from itertools import combinations
import ctypes as ct

from src.sage.utils import *
from src.sage.c_config import *

@dataclass
class State:
    i: int
    y: int
    d1: list
    d2: list
    prefix: list

def hamming_weight(x):
    x -= (x >> _sage_const_1 ) & _sage_const_0x5555555555555555 
    x = (x & _sage_const_0x3333333333333333 ) + ((x >> _sage_const_2 ) & _sage_const_0x3333333333333333 )
    x = (x + (x >> _sage_const_4 )) & _sage_const_0x0f0f0f0f0f0f0f0f 
    return ((x * _sage_const_0x0101010101010101 ) & _sage_const_0xffffffffffffffff  ) >> _sage_const_56 

def preprocess(f):
    for v in f.parent.gens():
        if v**_sage_const_2  in f.monomials():
            f = f + v**_sage_const_2  + v
    return f

def lex_idx(i, j, n):
    i, j = (i, j) if i < j else (j, i)
    return n + sum((n - k) for k in range(_sage_const_1 , i + _sage_const_2 )) - (n - j - _sage_const_1 )

# Get index position of first bit set (if any).
def bit1(x):
    x = x&-x

    x = int(x).bit_length()

    return None if x == _sage_const_0  else x-_sage_const_1 

# Get index position of second bit set (if any).
def bit2(x):
    # Remove first set bit and get position of the remaining 'first' bit.
    return bit1(x ^ (x&-x))

def init(f, n, n1, prefix):
    s = State(i = _sage_const_0 , y = f[_sage_const_0 ], d1=[_sage_const_0 ]*n1, d2=[[_sage_const_0 ]*n1 for _ in range(n1)], prefix=prefix)

    for k in range(n1):
        for j in range(k):
            s.d2[k][j] = f[lex_idx(j + (n - n1), k + (n - n1), n)] # Alter this function in old FES

    s.d1[_sage_const_0 ] = f[_sage_const_1  + n - n1]
    for k in range(_sage_const_1 , n1):
        s.d1[k] = s.d2[k][k-_sage_const_1 ] ^ f[_sage_const_1  + k + (n - n1)]

    # add pre-evaluation for prefix variables
    for idx in prefix:
        for k in range(n1):
            s.d1[k] ^= f[lex_idx(idx, k + (n - n1), n)] # Alter this function in old FES
            
        s.y ^= f[idx + _sage_const_1 ]

    for i, j in combinations(prefix, _sage_const_2 ):
        idx = lex_idx(i, j, n) # Alter this function in old FES
        s.y ^= f[idx] # Index into this here

    return s

def update(s, f, n, n1, prefix):
    if s == None:
        return init(f, n, n1, prefix)

    off = [v for v in s.prefix if v not in prefix]
    on = [v for v in prefix if v not in s.prefix]

    # turn old variables off
    for idx in off:
        for k in range(n1):
            s.d1[k] ^= f[lex_idx(idx, k + (n - n1), n)] 

        s.y ^= f[idx + _sage_const_1 ]

    for i in off:
        for j in [v for v in s.prefix if v not in off]:
            s.y ^= f[lex_idx(i, j, n)]

    for i, j in combinations(off, _sage_const_2 ):
        s.y ^= f[lex_idx(i, j, n)]

    # turn new variables on
    for idx in on:
        for k in range(n1):
            s.d1[k] ^= f[lex_idx(idx, k + (n - n1), n)]

        s.y ^= f[idx + _sage_const_1 ]

    for i in on:
        for j in [v for v in prefix if v not in on]:
            s.y ^= f[lex_idx(i, j, n)]

    for i, j in combinations(on, _sage_const_2 ):
        s.y ^= f[lex_idx(i, j, n)]

    s.prefix = prefix

    return s

def step(s):
    s.i = s.i + _sage_const_1 
    k1 = bit1(s.i)
    k2 = bit2(s.i)

    if k2:
        s.d1[k1] ^= s.d2[k2][k1]

    s.y ^= s.d1[k1]

def fes_eval(f, n, n1 = None, prefix=[], s = None, compute_parity=False):

    if n1 == None:
        n1 = n

    if compute_parity:
        parities = _sage_const_0 
    else:
        res = []
    
    if s == None:
        s = init(f, n, n1, prefix)
    
    pre_x = sum([_sage_const_1 <<i for i in prefix])

    if s.y == _sage_const_0 :
        if compute_parity:
            parities ^= _sage_const_2 **(n1 + _sage_const_1 ) - _sage_const_1 
            # if pre_x == int(209): print(parities)
        else:
            res.append(((s.i ^ (s.i >> _sage_const_1 )) << (n-n1)) | pre_x)

    while s.i < _sage_const_2 **n1 - _sage_const_1 :
        step(s)

        if s.y == _sage_const_0 :
            if compute_parity:
                parities ^= _sage_const_1 
                # if pre_x == int(209): print(parities)
                z = (s.i ^ (s.i >> _sage_const_1 ))
                for pos in range(n1):
                    if z & (_sage_const_1  << pos) == _sage_const_0 :
                        parities ^= (_sage_const_1  << (pos + _sage_const_1 ))
                        # if pre_x == int(209): print(parities)
            else:
                res.append(((s.i ^ (s.i >> _sage_const_1 )) << (n-n1)) | pre_x)
    # reset s.i to initial state
    s.i = _sage_const_0 
    for i in range(n1-_sage_const_1 ):
        s.d1[i] ^= s.d2[n1-_sage_const_1 ][i]
    s.y ^= s.d1[n1-_sage_const_1 ] ^ s.d2[n1-_sage_const_1 ][n1-_sage_const_2 ]
    # if pre_x == int(209): print("--")
    if compute_parity:
        return parities 
    return res

# Assumes vars is either a ring object or an int.
def bruteforce(system, vars, n1, d):
    solutions = []
    if type(vars) is int:
        n = len(vars)
        system = bitslice(system, vars)
    else:
        n = vars
    s = None
    for i in range(_sage_const_2 **(n - n1)):
        if hamming_weight(i) > d:
            continue
        prefix = [pos for pos, b in enumerate(reversed(bin(i)[_sage_const_2 :])) if b == "1"]
        s = update(s, system, n, n1, prefix)
        sub_sol = fes_eval(system, n, n1, prefix, s)
        solutions += [convert(sol, n) for sol in sub_sol]
    return solutions

def c_bruteforce(system, n, n1, d):
    solutions = []
    c_system = (C_POLY_T * len(system))(*system)
    c_solutions = (C_VARS_T * int((_sage_const_1  << n)))(_sage_const_0 )

    args = [Type.P(C_POLY_T), Type.U, Type.U, Type.U, Type.P(C_VARS_T)]
    res = Type.U
    brute = fetch_c_func("bruteforce", args, res)
    sol_amount = brute(c_system, n, n1, d, c_solutions)

    py_list = []
    for i in range(sol_amount):
        py_list.append(int(c_solutions[i]))

    return sol_amount, py_list 

def c_fes(system, n, m):
    c_system = (C_POLY_T * len(system))(*system)
    c_solutions = (C_VARS_T * int(_sage_const_1  << n))(_sage_const_0 )

    args = [Type.P(C_POLY_T), Type.U, Type.U, Type.P(C_VARS_T)]
    res = Type.U 
    fes_func = fetch_c_func("fes", args, res)
    sol_amount = fes_func(c_system, n, m, c_solutions)

    solutions = []
    if sol_amount > _sage_const_0 :
        for i in range(sol_amount):
            solutions.append(int(c_solutions[i]))

    return solutions

def test_c_fes(sys_tuple):
    system, n, m, ring, _ = sys_tuple

    sl_system = bitslice(system, ring.gens())
    solutions = c_fes(sl_system, n, m)

    if not all(all(f(*convert(s, n)) == _sage_const_0  for f in system) for s in solutions):
        print(solutions)
        print("Incorrect solutions.")
        return False
    print("All solutions verified.")
    return True
    

def test_c_fes_eval(sys_tuple):
    system, n, _, ring, _ = sys_tuple
    n1 = int(ceil(n/(_sage_const_5p4 )))
    # d = randint(1, n - n1)
    d = _sage_const_4  # TODO
    print(system)
    print(n, n1, d)
    system = bitslice(system, ring.gens())
    amount, c_solutions = c_bruteforce(system, n, n1, d)  
    py_solutions = [index_of(sol) for sol in bruteforce(system, n, n1, d)]
    c_solutions.sort()
    py_solutions.sort()
    print(py_solutions)
    print(c_solutions)
    if amount != len(py_solutions):
        print("Amount of solutions differ")
        print(c_solutions)
        print(py_solutions)
        return False
    for s_c, s_p in zip(c_solutions, py_solutions):
        if s_c != s_p:
            print("Solutions differ!", s_c, "!=", s_p)
            print(c_solutions, py_solutions)
            return False
    return True 

if __name__ == "__main__":
    ring = GF(_sage_const_2 )['x0, x1, x2, x3, x4, x5, x6, x7, x8, x9']; (x0, x1, x2, x3, x4, x5, x6, x7, x8, x9,) = ring._first_ngens(10)
    sys_tuple = ([x0*x2 + x1*x2 + x0*x3 + x2*x3 + x1*x4 + x2*x4 + x0*x5 + x3*x5 + x4*x5 + x0*x6 + x3*x6 + x4*x6 + x0*x7 + x1*x7 + x4*x7 + x5*x7 + x6*x7 + x4*x8 + x7*x8 + x1*x9 + x2*x9 + x5*x9 + x6*x9 + x8*x9 + x0 + x7 + x9, x0*x1 + x3*x4 + x3*x5 + x4*x5 + x2*x6 + x3*x6 + x4*x6 + x1*x7 + x4*x7 + x5*x7 + x6*x7 + x0*x8 + x5*x8 + x6*x8 + x0*x9 + x1*x9 + x4*x9 + x5*x9 + x6*x9 + x7*x9 + x8*x9 + x2 + x4 + x5 + x6 + x7 + x8 + x9 + _sage_const_1 , x0*x3 + x0*x4 + x1*x4 + x1*x5 + x3*x5 + x4*x6 + x0*x7 + x1*x7 + x2*x7 + x3*x7 + x5*x7 + x6*x7 + x0*x8 + x0*x9 + x2*x9 + x3*x9 + x5*x9 + x0 + x1 + x2 + x3 + x4 + x6 + x7 + x9], _sage_const_10 , int(ceil(_sage_const_10 /_sage_const_5p4 )) + _sage_const_1 , ring, None)
    print(test_c_fes_eval(sys_tuple))

