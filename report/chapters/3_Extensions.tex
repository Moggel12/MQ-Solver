\section{Extensions to the original scheme (approx. 5-10 pages)} \label{sec:ext}
The spatial complexity of Dinur's polynomial-method algorithm is one of the greatest hindrances to an implementation of the solver being viable in practice. This problem was also acknowledged by Dinur in \cite{cryptoeprint:2021/578} and mitigation was introduced as the \textit{memory efficient Möbius transform}. Although this alternative version of the Möbius transform was not implemented in practice in this project, it is described for the sake of completeness in \cref{sec:ext:mem_mob}. Other than describing mitigations for the memory bottlenecks in the algorithm, this section also introduces a FES (see \cref{sec:prereq:fes}) based interpolation procedure as a complete alternative to the use of the Möbius transform for polynomial interpolation, this is described in \cref{sec:ext:fes_interp}.
 
\subsection{Memory efficient Möbius transform} \label{sec:ext:mem_mob}
The proposal by Dinur that should mitigate the memory problems with the algorithm focuses on how the $U$ polynomials are evaluated using the Möbius transform. The standard approach described is to have \cref{alg:output} interpolate the $U$ polynomials in each round independently, then evaluate them, and then store their solutions. The alternative approach interpolates multiple sets of $U$ polynomials first, in order to then interleave the evaluation and solution testing on these multiple sets of $U$ polynomials in parallel. The evaluation process is specifically also altered to use the \textit{memory-efficient Möbius transform}.

Typically, the approach for using the Möbius transform for evaluation is to feed the it a full array of size $2^n$ bits representing the polynomial, however, for the memory-efficient approach we may assume the polynomial is represented by a bit array of size $\binom{n}{\downarrow d}$ (see \cref{sec:prereq:dinur:notation} for notation). 

The idea behind this approach is to use the recursive formula 
$$
    F(x_0, \dots x_{n - 1}) = x_0 \cdot F_1(x_1,\dots x_{n - 1}) + F_2(x_1,\dots x_{n - 1})
$$
by evaluating
$$
    F_2(x_1, \dots x_{n - 1}) = F(0, x_1, \dots x_{n - 1})
$$ 
first, followed by 
$$
    F_1(x_1, \dots x_{n - 1}) = F(0,\dots x_{n-1}) + F(1, \dots x_{n - 1})$$
for the first $k \approx n - \log \binom{n}{\downarrow d}$ recursive levels and then switching to the in-place approach afterward. These top $k$ levels are performed independently by allocating two arrays, set to be an \textit{input} and an \textit{output} array for the current level.
\td{PROBABLY JUST DELETE}
 
\subsection{Polynomial interpolation using FES} \label{sec:ext:fes_interp}

\subsubsection{Memory efficiency using FES-based interpolation} \label{sec:ext:mem_dinur}

\newpage
